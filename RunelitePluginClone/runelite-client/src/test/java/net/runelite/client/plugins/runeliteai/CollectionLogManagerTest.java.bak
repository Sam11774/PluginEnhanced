/*
 * Copyright (c) 2024, RuneLiteAI Team
 * All rights reserved.
 */
package net.runelite.client.plugins.runeliteai;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;

import org.junit.Before;
import org.junit.Test;
import org.junit.After;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.Map;

/**
 * Unit tests for CollectionLogManager
 * Tests collection log parsing, achievement tracking, and progression analysis
 */
public class CollectionLogManagerTest {

    @Mock
    private Client client;

    @Mock
    private DataCollectionManager dataCollectionManager;

    @Mock
    private Widget collectionLogWidget;

    @Mock
    private Widget categoryWidget;

    private CollectionLogManager collectionLogManager;
    private AutoCloseable mocks;

    @Before
    public void setUp() {
        mocks = MockitoAnnotations.openMocks(this);
        
        // Setup widget mocks
        when(client.getWidget(621, 2)).thenReturn(collectionLogWidget); // Main collection log widget
        when(collectionLogWidget.isHidden()).thenReturn(false);
        when(collectionLogWidget.getChild(6)).thenReturn(categoryWidget); // Bosses category
        
        collectionLogManager = new CollectionLogManager(client, dataCollectionManager);
    }

    @After
    public void tearDown() throws Exception {
        if (mocks != null) {
            mocks.close();
        }
    }

    @Test
    public void testCollectionLogParsing() {
        // Test basic collection log parsing
        long timestamp = System.currentTimeMillis();
        
        // Setup widget to return as visible
        when(collectionLogWidget.isHidden()).thenReturn(false);
        
        collectionLogManager.parseCollectionLog(timestamp);
        
        // Verify that parsing was attempted
        verify(client, atLeastOnce()).getWidget(621, 2);
    }

    @Test
    public void testCollectionLogNotOpen() {
        // Test when collection log is not open
        when(client.getWidget(621, 2)).thenReturn(null);
        
        long timestamp = System.currentTimeMillis();
        collectionLogManager.parseCollectionLog(timestamp);
        
        // Should return early without processing
        verify(dataCollectionManager, never()).recordCollectionLogProgress(any());
    }

    @Test
    public void testCollectionLogHidden() {
        // Test when collection log widget is hidden
        when(collectionLogWidget.isHidden()).thenReturn(true);
        
        long timestamp = System.currentTimeMillis();
        collectionLogManager.parseCollectionLog(timestamp);
        
        // Should return early without processing
        verify(dataCollectionManager, never()).recordCollectionLogProgress(any());
    }

    @Test
    public void testChatMessageParsing() {
        // Test collection log unlock message parsing
        String unlockMessage = "New item added to your collection log: Abyssal whip";
        long timestamp = System.currentTimeMillis();
        
        collectionLogManager.parseChatMessage(unlockMessage, timestamp);
        
        // Verify that unlock was recorded
        verify(dataCollectionManager, atLeastOnce()).recordCollectionLogProgress(any());
    }

    @Test
    public void testCollectionLogCompletion() {
        // Test collection log completion message
        String completionMessage = "Congratulations, you've completed the Giant Mole collection log!";
        long timestamp = System.currentTimeMillis();
        
        collectionLogManager.parseChatMessage(completionMessage, timestamp);
        
        // Verify that completion was recorded
        verify(dataCollectionManager, atLeastOnce()).recordCollectionLogProgress(any());
    }

    @Test
    public void testCollectionLogMilestone() {
        // Test collection log milestone message
        String milestoneMessage = "Collection log count: 150";
        long timestamp = System.currentTimeMillis();
        
        collectionLogManager.parseChatMessage(milestoneMessage, timestamp);
        
        // Verify that milestone was recorded
        verify(dataCollectionManager, atLeastOnce()).recordCollectionLogProgress(any());
    }

    @Test
    public void testNonCollectionLogMessage() {
        // Test that non-collection log messages are ignored
        String normalMessage = "Hello world!";
        long timestamp = System.currentTimeMillis();
        
        collectionLogManager.parseChatMessage(normalMessage, timestamp);
        
        // Should not record anything
        verify(dataCollectionManager, never()).recordCollectionLogProgress(any());
    }

    @Test
    public void testBossKillCountTracking() {
        // Test boss kill count messages
        String[] bossMessages = {
            "Your Abyssal Sire kill count is: 47",
            "Your Cerberus kill count is: 123",
            "Your Vorkath kill count is: 89"
        };
        
        long timestamp = System.currentTimeMillis();
        
        for (String message : bossMessages) {
            collectionLogManager.parseChatMessage(message, timestamp);
        }
        
        // Verify that all boss kills were recorded
        verify(dataCollectionManager, times(bossMessages.length)).recordCollectionLogProgress(any());
    }

    @Test
    public void testRareDropTracking() {
        // Test rare drop messages
        String[] dropMessages = {
            "You have a funny feeling like you're being followed.",
            "You feel something weird sneaking into your backpack.",
            "You have been given: Abyssal whip"
        };
        
        long timestamp = System.currentTimeMillis();
        
        for (String message : dropMessages) {
            collectionLogManager.parseChatMessage(message, timestamp);
        }
        
        // Pet and rare drop messages should be tracked
        verify(dataCollectionManager, atLeast(1)).recordCollectionLogProgress(any());
    }

    @Test
    public void testCategoryParsing() {
        // Test parsing specific categories
        String[] categories = {"bosses", "raids", "clues", "minigames", "other"};
        
        for (String category : categories) {
            CollectionLogEntry entry = collectionLogManager.getEntry(category, "test_entry");
            // Entry might be null if not found, which is expected for test data
            assertNotNull("Category parsing should be available", collectionLogManager);
        }
    }

    @Test
    public void testParsingCooldown() {
        // Test that parsing respects cooldown period
        long timestamp1 = System.currentTimeMillis();
        long timestamp2 = timestamp1 + 1000; // 1 second later (less than 5 second cooldown)
        
        when(collectionLogWidget.isHidden()).thenReturn(false);
        
        collectionLogManager.parseCollectionLog(timestamp1);
        collectionLogManager.parseCollectionLog(timestamp2);
        
        // Second parse should be skipped due to cooldown
        verify(client, atMost(2)).getWidget(621, 2); // Allow for setup calls
    }

    @Test
    public void testCooldownExpiry() {
        // Test that cooldown expires and allows parsing
        long timestamp1 = System.currentTimeMillis();
        long timestamp2 = timestamp1 + 6000; // 6 seconds later (more than 5 second cooldown)
        
        when(collectionLogWidget.isHidden()).thenReturn(false);
        
        collectionLogManager.parseCollectionLog(timestamp1);
        collectionLogManager.parseCollectionLog(timestamp2);
        
        // Both parses should proceed
        verify(client, atLeast(2)).getWidget(621, 2);
    }

    @Test
    public void testMultipleUnlocks() {
        // Test multiple collection log unlocks in sequence
        String[] unlockMessages = {
            "New item added to your collection log: Dragon chainbody",
            "New item added to your collection log: Dragon platelegs",
            "New item added to your collection log: Dragon full helm"
        };
        
        long baseTime = System.currentTimeMillis();
        
        for (int i = 0; i < unlockMessages.length; i++) {
            collectionLogManager.parseChatMessage(unlockMessages[i], baseTime + (i * 1000));
        }
        
        // All unlocks should be recorded
        verify(dataCollectionManager, times(unlockMessages.length)).recordCollectionLogProgress(any());
    }

    @Test
    public void testCombatAchievementTracking() {
        // Test combat achievement messages
        String[] achievementMessages = {
            "Congratulations, you've completed an easy combat task: Kill a goblin.",
            "Congratulations, you've completed a medium combat task: Kill Obor.",
            "Congratulations, you've completed a hard combat task: Kill the Corporeal Beast."
        };
        
        long timestamp = System.currentTimeMillis();
        
        for (String message : achievementMessages) {
            collectionLogManager.parseChatMessage(message, timestamp);
        }
        
        // Combat achievements should be tracked
        verify(dataCollectionManager, atLeast(achievementMessages.length)).recordCollectionLogProgress(any());
    }

    @Test
    public void testDiaryTaskCompletion() {
        // Test achievement diary task completion
        String[] diaryMessages = {
            "Congratulations, you've completed an Easy task in the Lumbridge & Draynor Diary.",
            "Congratulations, you've completed a Medium task in the Varrock Diary.",
            "Congratulations, you've completed a Hard task in the Fremennik Diary."
        };
        
        long timestamp = System.currentTimeMillis();
        
        for (String message : diaryMessages) {
            collectionLogManager.parseChatMessage(message, timestamp);
        }
        
        // Diary completions should be tracked
        verify(dataCollectionManager, atLeast(diaryMessages.length)).recordCollectionLogProgress(any());
    }

    @Test
    public void testQuestCompletion() {
        // Test quest completion tracking
        String questMessage = "Congratulations, quest complete: Dragon Slayer II";
        long timestamp = System.currentTimeMillis();
        
        collectionLogManager.parseChatMessage(questMessage, timestamp);
        
        // Quest completion should be tracked
        verify(dataCollectionManager, atLeastOnce()).recordCollectionLogProgress(any());
    }

    @Test
    public void testLevelUpTracking() {
        // Test level up messages for collection log relevant skills
        String[] levelMessages = {
            "Congratulations, you just advanced a Slayer level.",
            "Congratulations, you just advanced a Fishing level.",
            "Congratulations, you just advanced an Attack level."
        };
        
        long timestamp = System.currentTimeMillis();
        
        for (String message : levelMessages) {
            collectionLogManager.parseChatMessage(message, timestamp);
        }
        
        // Level ups might be tracked for collection log context
        // Verify at least some processing occurred
        assertTrue("Level up messages should be processed", true);
    }

    @Test
    public void testCacheManagement() {
        // Test that collection log entries are cached properly
        String unlockMessage = "New item added to your collection log: Abyssal whip";
        long timestamp = System.currentTimeMillis();
        
        // Process same message multiple times
        collectionLogManager.parseChatMessage(unlockMessage, timestamp);
        collectionLogManager.parseChatMessage(unlockMessage, timestamp + 1000);
        
        // Should handle duplicate messages gracefully
        verify(dataCollectionManager, atLeast(1)).recordCollectionLogProgress(any());
    }

    @Test
    public void testGetAllEntries() {
        // Test retrieving all collection log entries
        Map<String, CollectionLogEntry> allEntries = collectionLogManager.getAllEntries();
        
        assertNotNull("Should return a map of entries", allEntries);
        // Map might be empty if no data has been collected yet
    }

    @Test
    public void testCompletionTracking() {
        // Test tracking completion status
        String categoryId = "bosses";
        String entryId = "giant_mole";
        
        collectionLogManager.trackCompletion(categoryId, "Giant Mole");
        
        // Verify that completion tracking is called
        assertTrue("Completion tracking should work", true);
    }

    @Test
    public void testPerformanceRequirements() {
        // Test that collection log parsing meets performance requirements
        long startTime = System.nanoTime();
        
        // Parse multiple messages
        for (int i = 0; i < 100; i++) {
            String message = "New item added to your collection log: Test item " + i;
            collectionLogManager.parseChatMessage(message, System.currentTimeMillis() + i);
        }
        
        long endTime = System.nanoTime();
        long durationMs = (endTime - startTime) / 1_000_000;
        
        assertTrue("Collection log parsing should be fast (under 50ms), took: " + durationMs + "ms", 
                   durationMs < 50);
    }

    @Test
    public void testErrorHandling() {
        // Test error handling with malformed messages
        String[] malformedMessages = {
            null,
            "",
            "New item added to your collection log:", // Missing item name
            "Collection log count:", // Missing count
            "Congratulations, you've completed the collection log!" // Missing boss name
        };
        
        long timestamp = System.currentTimeMillis();
        
        for (String message : malformedMessages) {
            try {
                collectionLogManager.parseChatMessage(message, timestamp);
                // Should not crash on malformed messages
                assertTrue("Should handle malformed messages gracefully", true);
            } catch (Exception e) {
                fail("Should not throw exception on malformed message: " + e.getMessage());
            }
        }
    }

    @Test
    public void testMessagePatternMatching() {
        // Test various message pattern variations
        String[] validMessages = {
            "New item added to your collection log: Abyssal whip",
            "new item added to your collection log: dragon dagger", // Different case
            "Congratulations, you've completed the Giant Mole collection log!",
            "Collection log count: 42",
            "Your Boss kill count is: 123"
        };
        
        long timestamp = System.currentTimeMillis();
        
        for (String message : validMessages) {
            collectionLogManager.parseChatMessage(message, timestamp);
        }
        
        // All valid messages should be processed
        verify(dataCollectionManager, atLeast(validMessages.length - 1)).recordCollectionLogProgress(any());
    }

    // Helper class for collection log entries
    public static class CollectionLogEntry {
        public String category;
        public String entryName;
        public int completedItems;
        public int totalItems;
        public boolean isCompleted;
        public long lastUpdate;
    }
}